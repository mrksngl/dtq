
#ifdef _HAVE_CONFIG_H
#include <config.h>
#endif

#include "parser.h"

#include <dtq-bison.h>
#include <stdlib.h>
#include <stdbool.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>

/* flex and bison stuff */

typedef struct yy_buffer_state * YY_BUFFER_STATE;
extern int yyparse();
extern YY_BUFFER_STATE yy_scan_string(const char * str);
extern void yy_delete_buffer(YY_BUFFER_STATE buffer);

/** Parse a node test from a string
 * \param expr node test expression
 * \return AST of the expression on success, NULL otherwise.
 * \note In case of an error (e.g. syntax error), the error is printed to
 *  stderr.
 */
struct NodeTest * parseNodeTestExpr(const char * expr)
{
	struct NodeTest * parsedExpression;

	/* tell the lexer to scan the given expression string */
	YY_BUFFER_STATE buffer = yy_scan_string(expr);
	/* let the parser do its magic */
	int ret = yyparse(&parsedExpression, expr);
	/* free resources */
	yy_delete_buffer(buffer);

	if (ret) {
		/* parsing failed */
		return NULL;
	} else {
		/* success */
		return parsedExpression;
	}
}

/** Callback for lexer error
 * \param yytext unknown character (only [0] is filled by now)
 */
void lexError(const char * yytext)
{
	fprintf(stderr, "Unknown character '%c'\n", *yytext);
}

/** Callback for parser error
 * \param parsedExpression unneeded
 * \param expr unparsed expression (=expr of praseNodeTest())
 * \param s error string, generated by bison
 */
void yyerror(struct NodeTest ** parsedExpression, const char * expr,
	const char * err)
{
	/* we want to print something like that:
	 *
	 * Syntax error at some/expression/errorHERE/unparsed
	 *                                 ^^^^^^^^^
	 *
	 * i.e. we want to underline the part of the expression containing the
	 *  error. If the expression is too long, we shorten it on the left
	 *  and maybe right side.
	 */

	size_t errlen = yylloc.last_column - yylloc.first_column + 1;

	/* this is where the erroneous substring begins */
	size_t offset = yylloc.first_column - 1;
	size_t printLen = strlen(expr);
	bool truncate_l = false;
	bool truncate_r = false;
	if (printLen > 60) {
		/* truncate only if the complete expression exceeds 60 characters */
		if (offset >= 10) {
			/* truncate on the left if there are more than 10 characters:
			 * -> limit it to 5
			 */
			expr += offset - 5;
			printLen -= offset - 5;
			offset = 5;
			truncate_l = true;
		}
		if (printLen - errlen >= 10) {
			/* truncate on the right if there are more than 10 characters:
			 * -> limit to 5
			 */
			printLen = errlen + 5;
			truncate_r = true;
		}
	}

	/* print generated message of the parser */
	offset += fprintf(stderr, "%s at ", err);
	if (truncate_l) {
		/* if truncated on the left : print indicator */
		offset += 1;
		fprintf(stderr, "…");
	}
	/* print the expression (i.e. it's erroneous substring) */
	fprintf(stderr, "%.*s", (int)printLen, expr);
	if (truncate_r) /* if truncated on the right: print indicator */
		fprintf(stderr, "…");
	fprintf(stderr, "\n");

	/* print spaces until we reach the erroneous substring */
	const char spc[10] = { [0 ... 9] = ' ' };
	for (; offset >= 10; offset -= 10)
		fwrite(spc, sizeof *spc, sizeof spc, stderr);
	if (offset)
		fwrite(spc, sizeof *spc, offset, stderr);

	/* print circumflexes below the erroneous substring */
	const char mark[10] = { [0 ... 9] = '^' };
	for (; errlen >= 10; errlen -= 10)
		fwrite(mark, sizeof *mark, sizeof mark, stderr);
	if (errlen)
		fwrite(mark, sizeof *mark, errlen, stderr);
	fputc('\n', stderr);
}

/** Instantiate a new node test.
 * \param type node test type
 * \param name optional node name, ownership is transferred
 * \param properties optional properties test, ownership is transferred
 * \param subExpr optional sub expression, ownership is transferred
 * \param node test
 */
struct NodeTest * newNodeTest(enum NODE_TEST_TYPE type, char * name,
	struct PropertyTest * properties, struct NodeTest * subExpr)
{
	struct NodeTest * test = malloc(sizeof *test);
	assert(test);
	test->type = type;
	test->name = name;
	test->properties = properties;
	test->subTest = subExpr;
	return test;
}

/** Instantiate a new binary property test.
 * \param op operator
 * \param left left child
 * \param right child
 */
struct PropertyTest * newPropertyTestBinary(enum PROPERTY_TEST_OP op,
	struct PropertyTest * left, struct PropertyTest * right)
{
	struct PropertyTest * test = malloc(sizeof *test);
	assert(test);
	test->type = op;
	test->left = left;
	test->right = right;
	return test;
}

/** Instantiate a new unary property test.
 * \param op operator
 * \param child sub test
 */
struct PropertyTest * newPropertyTestUnary(enum PROPERTY_TEST_OP op,
	struct PropertyTest * child)
{
	struct PropertyTest * test = malloc(sizeof *test);
	assert(test);
	test->type = op;
	test->child = child;
	return test;
}

/** Instantiate a new atomic property test.
 * \param op operator
 * \param left left child
 * \param right child
 */
struct PropertyTest * newPropertyTestAtomic(struct AtomicPropertyTest * child)
{
	struct PropertyTest * test = malloc(sizeof *test);
	assert(test);
	test->type = PROPERTY_TEST_OP_ATOMIC;
	test->atomic = child;
	return test;
}

/** Instantiate a new atomic property existence atomic
 * \param property property name
 * \return property test
 */
struct AtomicPropertyTest * newAtomicPropertyTestExist(char * property)
{
	struct AtomicPropertyTest * test = malloc(sizeof *test);
	assert(test);
	test->type = ATOMIC_PROPERTY_TEST_TYPE_EXIST;
	test->property = property;
	return test;
}

/** Instantiate a new atomic property integer atomic
 * \param op comparison operator
 * \param property property name
 * \param integer integer to test against
 * \return property test
 */
struct AtomicPropertyTest * newAtomicPropertyTestInteger(
	enum ATOMIC_PROPERTY_TEST_OP op, char * property, int integer)
{
	struct AtomicPropertyTest * test = malloc(sizeof *test);
	assert(test);
	test->type = ATOMIC_PROPERTY_TEST_TYPE_INT;
	test->op = op;
	test->property = property;
	test->integer = integer;
	return test;
}

/** Instantiate a new atomic property string atomic
 * \param op comparison operator
 * \param property property name
 * \param string string to test against, ownership is transferred
 * \return property test
 */
struct AtomicPropertyTest * newAtomicPropertyTestString(
	enum ATOMIC_PROPERTY_TEST_OP op, char * property, char * string)
{
	struct AtomicPropertyTest * test = malloc(sizeof *test);
	assert(test);
	test->type = ATOMIC_PROPERTY_TEST_TYPE_STR;
	test->op = op;
	test->property = property;
	test->string = string;
	return test;
}

/** Free an atomic property atomic.
 * \param atomic atomic property test to be freed. May be NULL
 */
void freeAtomicPropertyTest(struct AtomicPropertyTest * test)
{
	if (!test)
		return;

	/* free also data if necessary */
	if (test->type == ATOMIC_PROPERTY_TEST_TYPE_STR)
		free(test->string);
	free(test->property);
	free(test);
}

/** Free a property atomic.
 * \param atomic property atomic to be freed. May be NULL
 */
void freePropertyTest(struct PropertyTest * test)
{
	if (!test)
		return;

	/* free all child properties */
	switch (test->type) {
	case PROPERTY_TEST_OP_AND:
	case PROPERTY_TEST_OP_OR: {
		struct PropertyTest * subTestLeft = test->left;
		struct PropertyTest * subTestRight = test->right;
		free(test);
		/* allow tail recursion, although it's most likely that only the right
		 * child will benefit from that.
		 */
		freePropertyTest(subTestLeft);
		freePropertyTest(subTestRight);
		break;
	}
	case PROPERTY_TEST_OP_NEG: {
		struct PropertyTest * subTest = test->child;
		free(test);
		/* allow tail recursion */
		freePropertyTest(subTest);
	}
		break;
	case PROPERTY_TEST_OP_ATOMIC: {
		struct AtomicPropertyTest * subTest = test->atomic;
		free(subTest);
		/* allow tail recursion */
		freeAtomicPropertyTest(subTest);
	}
		break;
	}
}

/** Free a node atomic.
 * \param atomic node atomic to be freed. May be NULL
 */
void freeNodeTest(struct NodeTest * test)
{
	if (!test)
		return;

	free(test->name);
	freePropertyTest(test->properties);
	struct NodeTest * next = test->subTest;
	free(test);
	/* allow tail recursion */
	freeNodeTest(next);
}

/** Readable operator names */
static const char * testOperators[] = {
	[ATOMIC_PROPERTY_TEST_OP_EQ] = "=",
	[ATOMIC_PROPERTY_TEST_OP_NE] = "!=",
	[ATOMIC_PROPERTY_TEST_OP_LE] = "<=",
	[ATOMIC_PROPERTY_TEST_OP_GE] = ">=",
	[ATOMIC_PROPERTY_TEST_OP_LT] = "<",
	[ATOMIC_PROPERTY_TEST_OP_GT] = ">",
	[ATOMIC_PROPERTY_TEST_OP_CONTAINS] = "~="
};

/** Dump an atomic property atomic to stdout.
 * \param test property test to be printed
 */
static void printAtomicPropertyTest(const struct AtomicPropertyTest * test)
{
	const char * op = testOperators[test->op];
	switch (test->type) {
	case ATOMIC_PROPERTY_TEST_TYPE_EXIST:
		printf("%s", test->property);
		break;
	case ATOMIC_PROPERTY_TEST_TYPE_INT:
		printf("%s %s 0x%x", test->property, op, test->integer);
		break;
	case ATOMIC_PROPERTY_TEST_TYPE_STR:
		printf("%s %s \"%s\"", test->property, op, test->string);
		break;
	default:
		assert(false);
	}
}

/** Dump a property atomic to stdout.
 * \param atomic property test to be printed
 */
static void printPropertyTest(const struct PropertyTest * test)
{
	switch (test->type) {
	case PROPERTY_TEST_OP_AND:
		printf("(");
		printPropertyTest(test->left);
		printf(" & ");
		printPropertyTest(test->right);
		printf(")");
		break;
	case PROPERTY_TEST_OP_OR:
		printf("(");
		printPropertyTest(test->left);
		printf(" | ");
		printPropertyTest(test->right);
		printf(")");
		break;
	case PROPERTY_TEST_OP_NEG:
		printf("!(");
		printPropertyTest(test->child);
		printf(")");
		break;
	case PROPERTY_TEST_OP_ATOMIC:
		printAtomicPropertyTest(test->atomic);
		break;
	}
}

/** Dump a node atomic to stdout.
 * \param atomic node test to be printed
 */
void printNodeTest(const struct NodeTest * test)
{
	if (test->type != NODE_TEST_TYPE_ROOT)
		printf("/");

	if (test->type == NODE_TEST_TYPE_NODE && test->name)
		printf("%s", test->name);

	if (test->properties) {
		printf("[");
		printPropertyTest(test->properties);
		printf("]");
	}

	if (test->subTest)
		printNodeTest(test->subTest);
}
